# 트랜잭션과 잠금
## 트랜잭션
개념: 논리적인 작업 셋 자체가 100% 적용되거나, 롤백됨을 보장해주는 것

## 잠금
글로벌 락
- MySQL에서 제공하는 잠금 중에 가장 범위가 크다
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML 문장은 대기하게 된다s

테이블 락
- 개별 테이블 단위의 잠금
- 명시적으로 설정할 수 있으나, 주로 묵시적으로 락이 걸린다
- 데이터가 변경되는 테이블에 락을 걸고, 변경 이후에 락을 해제하는 형태로 적용된다
- InnoDB는 스토리지엔진 레벨에서 DML은 레코드 기반의 잠금이 적용, DDL같은 Schema 변경은 테이블락이 적용된다

유저 락
- 사용자가 임의로 문자열에 대해서 락을 거는 방법

네임 락
- `RENAME`을 통해서 테이블의 이름을 변경하는 경우 2개 테이블에 모두 잠금을 설정한다
- 실시간으로 테이블 이름을 변경해야하는 곳에서 주로 발생한다
- 예시
   ```sql
   RENAME TABLE a to a_back, b to a;
   ```

## InnoDB 스토리지 엔진 잠금
스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
- 레코드 기반의 잠금이기 때문에 MyISAM보다 뛰어난 동시성 처리를 제공한다

InnoDB는 비관적 잠금을 사용한다

잠금 종류
- 레코드 락
   - InnoDB는 레코드 자체가 아니라 인덱스를 잠근다
- 갭 락
- 넥스트 키 락
   - BinaryLog에 기록되는 쿼리가 슬레이브에서 실행될 때, 마스터에서 만들어낸 결과와 항상 동일하게 만들어내도록 보장하는 것이 주 목적
- 자동 증가 락
   - `AUTO_INCREMENT` 칼럼 속성에 적용되는 락
   - 테이블 수준의 잠금
   - 새로운 데이터를 저장하는 쿼리에만 적용된다
   - 잠금을 최소화하기 위해서 값은 항상 증가만 한다

인덱스 잠금
- InnoDB는 레코드 락을 지원하는데, 레코드락은 Index Level에서 작동한다
- 예시 쿼리
   ```sql
   update employees 
   set hire_date = now()
   where firstname = 'test'
     and lastname = 'name'
   ```
   - 위 쿼리에서 firstname에만 인덱스가 있다고 하면, 실제 변경되는 코드는 lastname까지 보겠지만, 잠금은 index 기반이기 때문에 fisrstname의 대상이 모두 잠기게 된다.
- 인덱스가 하나도 없는 테이블이라면 테이블을 풀스캔하면서 모두 잠기게 된다
- READ-COMMITTED를 사용하면서, 레코드 기반의 바이너리 로그를 사용한다면 이 문제를 해결할 수 있다
   - 이 경우 lastname까지 찾은 이후에, 나머지 잠금은 해제한다

## 격리 수준
READ UNCOMMITTED
- 커밋되지 않은 데이터도 읽을 수 있다
- DirtyRead 발생

READ COMMITTED
- 커밋된 데이터만 읽어오기 때문에 DirtyReady는 해결된다
- MVCC를 통해서 Undo 영역의 데이터를 읽어온다
- 데이터를 조회할 때마다 커밋된 데이터를 가져오기 때문에, 1개 트랜잭션 내에서 데이터를 읽을 때 서로 다른 데이터가 조회될 수 있다

REAPEATABLE READ
- MVCC의 TransactionId를 이용해서 ReapeatableRead를 지원한다
- 1개 트랜잭션에서는 데이터를 조회해도, 다른 트랜잭션에서의 변경여부와 상관없이 항상 동일한 데이터를 응답한다
- PhantomRead가 발생할 수 있다
   - 새로운 데이터가 Insert 되었을 때는 이 값이 조회될 수 있다

SERIALIZABLE