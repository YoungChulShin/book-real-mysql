# 실행계획
## 개요
쿼리 실행 순서
1. SQL 문장을 잘게 쪼개서 MYSQL 서버가 이해할 수 있는 수준으로 분리 - SQL 파서
2. 파싱 정보를 확인하면서 어떤 테이블로 부터 읽고 어떤 인덱스를 이용해서 데이터를 읽어야하는지 선택한다 - SQL 옵티마이저
3. 2번의 순서, 인덱스를 이용해서 스토리지 엔진으로부터 데이터를 가져온다 - 스토리지 엔진

통계 정보
- MySQL의 통계 정보는 대략의 레코드 건수와 인덱스의 유니크한 값의 개수 정도
- ANALYZER를 이용해서 통계 정보를 업데이트 할 수 있으나 InnoDB 테이블은 읽기/쓰기가 불가능하게 되므로 서비스 중에는 하지 않아야한다

## 실행 계획 분석
실행 계획 확인
```
EXPLAIN <<Query>>
```

### id 칼럼
기능
- SELECT 쿼리 별로 부여되는 식별자
- Table이 join 되는 것은 같은 id가 부여된다

### select_type 칼럼
SIMPLE
- union, subquery를 사용하지 않는 단순한 select 쿼리
- 쿼리가 아무리 복잡해서 simple 쿼리는 1개만 존재한다. 

PRIMARY
- union, subquery가 포함된 select 쿼리의 실행 계획에서 가장 바깥쪽의 쿼리

UNION
- union으로 결합한 쿼리 가운데, 첫번째를 제외한 두 번째 이후의 select 쿼리
- 첫번째 쿼리는 union 쿼리 결과로 결합된 전체 집합의 select_type이 표시된다. 예: 임시 테이블 
   ```sql
    explain
    select *
    from (
                (select emp_no from employees e1 limit 10)
                union all
                (select emp_no from employees e2 limit 10)
                union all
                (select emp_no from employees e3 limit 10)
        ) tb;


    +--+-----------+----------+
    |id|select_type|table     |
    +--+-----------+----------+
    |1 |PRIMARY    |<derived2>|
    |2 |DERIVED    |e1        |
    |3 |UNION      |e2        |
    |4 |UNION      |e3        |
    +--+-----------+----------+
   ```

DEPENDENT UNION
- dependent는 union 쿼리가 외부에 영향을 받는 다는 것을 의미한다
- 서브쿼리
   - 하나의 select 쿼리가 다른 select 쿼리를 포함하고 있으면 이를 서브쿼리라고 한다
   - 일반적으로 서브쿼리는 외부쿼리보다 먼저 실행되는데, 대부분 이 방식이 반대보다 빠르다. 
   - dependent 서브쿼리의 경우는 외부 쿼리의 결과로 동작하기 때문에, 외부 쿼리가 먼저 수행된다. 
   - 그래서 dependent가 포함된 쿼리는 비효율적인 경우가 많다. 

UNION RESULT
- union all이나 union 쿼리는 결과를 임시테이블로 생성하게 되는데, 실행계획상에서 이 임시테이블을 가리키는 라인

SUBQUERY
- FROM 절 이외에서 사용된 서브쿼리
   ```sql
    explain
    select e.first_name,
        (select count(*) from dept_emp de, dept_manager dm where dm.dept_no = de.dept_no) as count
    from employees e
    where e.emp_no = 10001;

    +--+-----------+-----+
    |id|select_type|table|
    +--+-----------+-----+
    |1 |PRIMARY    |e    |
    |2 |SUBQUERY   |dm   |
    |2 |SUBQUERY   |de   |
    +--+-----------+-----+
   ```

DEPENDENT SUBQUERY
- 서브쿼리가 바깥쪽 select 쿼리에서 정의된 칼럼을 사용하는 경우
- 외부쿼리가 먼저 수행되고 내부 쿼리가 수행되기 때문에 일반 서브쿼리보다는 속도가 느릴 경우가 많다
   ```sql
    explain
    select e.first_name,
        (select count(*)
            from dept_emp de, dept_manager dm
            where dm.dept_no = de.dept_no
            and de.emp_no = e.emp_no) as count
    from employees e
    where e.emp_no = 10001;

    +--+------------------+-----+
    |id|select_type       |table|
    +--+------------------+-----+
    |1 |PRIMARY           |e    |
    |2 |DEPENDENT SUBQUERY|de   |
    |2 |DEPENDENT SUBQUERY|dm   |
    +--+------------------+-----+
   ```

DERIVED
- 단위 select 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. 이때 생성되는 임시 테이블을 파생 테이블이라고 한다.
- 파생 테이블에는 인덱스가 없기 때문에 성능상 불리할 경우가 많다. 
- 가능하다면 drived는 join으로 해결할 수 있도록 바꿔주는 것이 좋다.

UNCACHEABLE SUBQUERY
- 일반적으로 서브쿼리는 동일한 조건에 대해서는 내부 캐시를 통해서 실행된다
   - dependent subquery는 외부 쿼리의 값 단위로 캐시된다
- uncacheable subquery는 `사용자 변수`, `UUID`, `RAND` 등 동적으로 변하는 요소가 쿼리에 사용될 때 캐시를 하지 못하는 의미로 표시된다

### table 칼럼
개념
- 테이블의 정보가 표시된다.
- 별칭이 사용되었으면 별칭을 표시한다. 테이블이 사용되지 않았으면(예: select now() 등) NULL이 표시된다.
- 테이블 칼럼에 `<derived>` 또는 `<union>`과 같이 `<>`로 둘러싸인 곳은 임시테이블을 의미한다. 

### type 칼럼
속도 순으로 정렬

summary
- const, eq_ref, ref
   - 동등 비교 연산자여야한다
   - 3가지 모두 좋은 접근 법으로 인덱스의 분포도가 나쁘지 않다면 성능상 문제를 일으키지 않는다
   - 쿼리 튜닝 시 이 3가지 접근법에 대해서는 크게 신경쓰지 않고 넘어가도 된다
- index, all
   - 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 보내야하는 웹서비스, OLTP 환경에서는 적합하지 않다

const
- 조건
   1. 레코드의 건수에 상관없이 쿼리가 PK, UK 칼럼을 이용하는 where 조건
   2. 반드시 1건을 반환하는 쿼리 방식
- const 인 경우 옵티마이저가 쿼리를 최적화하는 단계에서 상수화 한다
   ```sql
   select count(*)
   from employees e1
   where first_name(select first_name from employees e2 where emp_no = 10001)

   # 아래 쿼리가 최적화 시점에서는 'XXXX' 같은 상수로 변경된다
   # select first_name from employees e2 where emp_no = 10001 
   ```

eq_ref
- 조건
   1. join 쿼리에서 나타난다
   2. join에서 처음읽은 테이블의 칼럼 값을 다음 읽어야할 테이블의 PK 또는 UK 검색 조건에 사용될 경우
      - 이 조회는 1건의 결과를 반환한다
- 샘플
   ```sql
   explain
   select * from dept_emp de, employees e
   where e.emp_no = de.emp_no
   and de.dept_no = 'd005';

   # dept_emp의 조회 결과 값이 employees의 PK로 사용
   # +--+-----------+-----+----------+------+
   # |id|select_type|table|partitions|type  |
   # +--+-----------+-----+----------+------+
   # |1 |SIMPLE     |de   |NULL      |ref   |
   # |1 |SIMPLE     |e    |NULL      |eq_ref|
   # +--+-----------+-----+----------+------+
   ```

ref
- 조건
   1. 인덱스의 종류와 상관없이 동등 조건으로 검색할 때에는 ref 접근법이 사용된다
- 데이터가 1건이라는 보장이 없기 때문에 const, eq_ref보다 빠르지는 않지만, 충분히 빠른 조회 방법이다

range
- 조건
   1. 주로 `<, >, IS NULL, BETWEEN, IN, LIKE` 등의 연산자를 이용해서 인덱스를 검색할 때 사용된다
- 일반적으로 애플리케이션의 쿼리가 가장 많이 사용하는 접근 방식
- 속도 순서로는 우선순위가 낮지만, 이 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 어느정도 성능은 보장된다

index
- 개념: index 풀스캔
- 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건 수는 같다. 하지만 인덱스는 데이터 전체보다는 크기가 작아서 풀 테이블 스캔보다는 빠르게 처리된다
- 샘플
   ```sql 
   # dept_name index를 이용해서 풀스캔
   select * from departments order by dept_name
   ```

all
- 개념: 풀 테이블 스캔
- 가장 마지막에 선택되는 가장 비효율적인 방법
