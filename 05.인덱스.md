# 인덱스
쿼리튜닝
- 랜덤 I/O 자체를 줄여주는 것이 목적이다. 
- 쿼리 튜닝을 한다고 해서 랜덤 I/O를 순차 I/O로 실행할 방법은 많지 않다.

## 인덱스
데이터 저장
- 인덱스: Sorted Array 자료구조를 사용. 항상 정렬된 상태를 유지한다
- 데이터 파일: Array List 처럼 넣는대로 저장된다. InnoDB는 PK 기준으로 정렬되어 저장된다. 

인덱스는 정렬된 상태를 유지해야하기 때문에 Insert, Update, Delete는 처리가 느리지만, 조회는 빠르다. 

### B-tree 인덱스
구조 및 특징
- 최상위에 루트 노드. 중간에 브랜치 노드. 마지막에 리프노드
- 인덱스의 리프노드는 실제 데이터를 찾기 위한 주소 값을 가진다
   - InnoDB는 PK에 의해서 클러스터링되기 때문에 PK 값 자체가 주소 역할을 한다

인덱스 키 추가
- 저장된 키 값을 이용해서 적당한 위치를 찾고, 레코드의 키값과 대상 주소 정보를 리프노드에 저장한다
- 리프노드에 공간이 없으면 노드가 분리되어야하는데, 이때는 상위 브랜치 노드까지 영향범위가 넓어진다
- InnoDB의 경우는 인덱스 키 추가를 바로 할 지, 지연처리할 지 선택할 수 있다
   - 버퍼 풀에 새로운 키 값을 추가해야할 페이지가 존재한다면 즉시 처리한다
   - 그게 아니라면 '인서트 버퍼'에 추가하고 백그라운드 작업으로 처리된다

인덱스 키 삭제
- 키 값이 저장된 리프노드를 찾아서 삭제 마크만 하면 완료된다

인덱스 키 변경
- 키 값을 삭제하고, 새로 추가하는 형태로 처리된다

키 검색
- 인덱스를 이용한 검색은 100% 일치 또는 앞 부분이 일치할 경우에 사용할 수 있다. 부등호 비교나 뒷부분이 일치하는 경우는 검색이 불가능하다
- 인덱스의 값이 변형된 후 비교될 경우에는 인덱스를 탈 수 없다

인덱스 키 값의 크기
- 페이지: 디스크에 데이터를 저장하는 가장 기본 단위.
   - 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위
   - 버퍼풀에서 데이터를 버퍼링하는 기본 단위
   - InnoDB의 페이지 크기는 16KB로 고정
- 예: 인덱스 키가 16바이트라면?
   - 1개 정보는 키-16바이트 + 주소-약12바이트를 저장할 수 있다
   - 16*1024/(16+12) = 585개
   - 만약에 인덱스 키의 크기가 더 커진다면 1개 페이지에 저장할 수 있는 인덱스의 개수는 더 줄어든다 -> 디스크를 읽는 횟수가 더 늘어난다

선택도(Selectivity, 기수성(Cardinality)
- 모든 인덱스의 키 값 가운데 유니크한 값의 수를 의미한다. 
   - 전체 인덱스 키 값은 100개인데, 유니크한 값의 수가 10개라면 선택도는 10이다
- 인덱스는 선택도가 높을 수록 검색 대상이 줄어들기 때문에, 그만큼 빠르게 처리된다
