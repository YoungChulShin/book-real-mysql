# 베스트 프랙티스
## 페이징 쿼리 개선
배경
- 일반적으로 페이징 쿼리는 `limit n, m`으로 구현한다. 이때 n은 페이지 정보가 올라갈 때마다 증가하는 값이며(=항목 수 만큼), 실제 쿼리는 이 값을 찾기 위해서 0부터 조회를 시작한다.

개선 방법
- __마지막 페이지의 아이템 번호를 알 수 있다면__, pk를 where 조건의 조건절로 추가할 수 있다. 이렇게하면 limit 쿼리에서 시작점을 0으로 할 수 있기 때문에 불필요한 디스크 읽기를 줄일 수 있다. 
   ```sql
   select *
   from tb_article 
   where board_id = 1 and article_id < 165
   order by article_id desc limit 0, 20;
   ```
 
## 큰 문자열 칼럼의 인덱스
배경
- innodb에서 인덱스는 하나의 레코드가 767바이트 이상을 넘을 수 없다

해결 방법
1. 칼럼 앞부분의 767바이트만 잘라서 인덱스를 생성하는 프리픽스 인덱스 사용
2. 해시 값을 이용해서 인덱스를 생성하는 방법 사용

해시 값을 이용한 인덱스 생성
1. 해시 칼럼 크기
   - MD5() 함수: CHAR(32) 또는 BINARY(16)
   - SHA() 함수: CHAR(40) 또는 BINARY(20)
2. 해시 칼럼 구현
   - 테이블에 해시 칼럼을 선언하고, 인덱스를 같이 정의한다
      ```sql
      create table acceess_log (
        ...
        access_url varchar(1000) not null,
        access_url_hash char(32) not null collate latin1_general_cs,
        index ix_accessurlhash(access_url_hash)
      )
      ```
3. 조회 쿼리 구현
   - 조회 조건에 hash 값과 실제 값을 같이 넣는다. hash 값이 중복될 수 있기 때문에 실제 값을 같이 넣어준다
      ```sql
      where access_url_hash = md5('http://test.com')
        and accees_url = 'http://test.com'
      ```

기타 함수
- md5(): md5 해시 함수
- sha(): sha 해시 함수
- hex(): 바이너리 값을 16진수 문자열로 변환
- unhex(): 문자열 값을 바이너리 값으로 변환

